<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>运行机制 · SimpleChain开发文档</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Simplechain模型说明"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="运行机制 · SimpleChain开发文档"/><meta property="og:type" content="website"/><meta property="og:url" content="https://simplechain.github.io/sipc-docs/"/><meta property="og:description" content="## Simplechain模型说明"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/sipc-docs/"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/sipc-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/sipc-docs/css/main.css"/><script src="/sipc-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/sipc-docs/"><h2 class="headerTitle">SimpleChain开发文档</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_1" target="_self">文档</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_25" target="_self">API</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_50" target="_self">FAQ</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_51" target="_self">在线技术支持</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>底层核心技术</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">快速了解</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_1">概述</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_2">快速开始</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_3">搭建节点</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">sipc和sipc代币协议</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_52">技术术语</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_4">sipc代币</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_5">在SIPC上发行代币</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">基础数据结构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_6">配置</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_7">创世块</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_8">账户</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_9">交易</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_10">区块</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_11">交易回执</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_12">SimpleChain架构设计</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_13">数据结构和存储</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_55">数据同步优化</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">底层核心技术</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_15">P2P网络</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_17">虚拟机</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/sipc-docs/docs/docs_18">运行机制</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_19">异常处理</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">智能合约</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_20">智能合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_21">深入理解Solidity</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_22">合约模版</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_23">合约开发和部署</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发者工具</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_24">搭建测试链</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_25">Sipc API</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_26">跨链API</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_27">SimPlug</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_28">sdk</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">跨链</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_53">跨链方案</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_30">子链模版</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_54">跨链流程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Dapp开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_31">合约编译器</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_32">编写合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_33">发布合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_34">开发流程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">挖矿</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_35">Sipc挖矿</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_36">矿池接入</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_37">GPU挖矿</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_38">SimPool</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_39">SimpleNode x1挖矿教程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_40">SIPC.VIP</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_41">Sipc全节点钱包</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_42">ChainBox</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_43">区块链浏览器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">生态</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_44">交易所对接</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_45">社区项目</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_46">社区活动</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_47">社区入口</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">落地方案</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_48">落地案例</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_49">构建应用</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">FAQ</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_50">FAQ</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">技术支持</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_51">在线技术支持</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">运行机制</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="simplechain模型说明"></a><a href="#simplechain模型说明" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simplechain模型说明</h2>
<p>Simplechain的本质就是一个基于交易的状态机(transaction-based state machine)。在计算机科学中，一个状态机是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。</p>
<p><img src="https://i.loli.net/2020/05/27/usmOjFxSitVPlkf.png" alt="18.1.png"></p>
<p>根据Simplechain的状态机，我们从创世纪状态(genesis state)开始。在网络中还没有任何交易的产生状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着Simplechain当前的状态。</p>
<p><img src="https://i.loli.net/2020/05/27/m7EG46heCawcWMV.png" alt="18.2.png"></p>
<p>Simplechain的状态有百万个交易。这些交易都被“组团”到一个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来。</p>
<p><img src="https://i.loli.net/2020/05/27/jGzNRKD4SxkgtTW.png" alt="18.3.png"></p>
<p>为了让一个状态转换成下一个状态，交易必须是有效的。为了让一个交易被认为是有效的，它必须要经过一个验证过程，此过程也就是挖矿。挖矿就是一组节点（即电脑）用它们的计算资源来创建一个包含有效交易的区块出来。</p>
<p>为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。</p>
<p>证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏是什么？Simplechain使用一种内在数字代币—Sipc作为奖赏。每次矿工证明了一个新区块，那么就会产生一个新的Sipc并被奖励给矿工。</p>
<p>不论什么时候只要多个路径产生了，一个”分叉“就会出现。我们通常都想避免分叉，因为它们会破坏系统，强制人们去选择哪条链是他们相信的链。</p>
<p><img src="https://i.loli.net/2020/05/27/lKJ1nqIPxmhHSWB.png" alt="18.4.png"></p>
<p>为了确定哪个路径才是最有效的以及防止多条链的产生，Simplechain使用了一个叫做“GHOST协议(GHOST protocol.)”的数学机制。</p>
<pre><code class="hljs">GHOST = Greedy Heaviest Observed Subtree
</code></pre>
<p>简单来说，GHOST协议就是让我们必须选择一个在其上完成计算最多的路径。一个方法确定路径就是使用最近一个区块（叶子区块）的区块号，区块号代表着当前路径上总的区块数（不包含创世纪区块）。区块号越大，路径就会越长，就说明越多的挖矿算力被消耗在此路径上以达到叶子区块。使用这种推理就可以允许我们赞同当前状态的权威版本。</p>
<p><img src="img/18.5.png" alt=""></p>
<p>现在你大概对Simplechain有个基本的认识，让我们在再深入了地解一下Simplechain系统主要组成部分：</p>
<ul>
<li>账户(accounts)</li>
<li>状态(state)</li>
<li>损耗和费用(gas and fees)</li>
<li>交易(transactions)</li>
<li>区块(blocks)</li>
<li>交易执行(transaction execution)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="账户"></a><a href="#账户" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>账户</h2>
<p>Simplechain的全局“共享状态”是有很多账户组成的，这些账户可以通过消息传递架构来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在Simplechain中一个地址是160位的标识符，用来识别账户的。</p>
<p>这是两种类型的账户：</p>
<ol>
<li>外部拥有的账户，被私钥控制且没有任何代码与之关联</li>
<li>合约账户，被它们的合约代码控制且有代码与之关联</li>
</ol>
<p><img src="https://i.loli.net/2020/05/27/YgFlSj93nILCzAq.png" alt="18.6.png"></p>
<h3><a class="anchor" aria-hidden="true" id="外部拥有账户与合约账户的比较"></a><a href="#外部拥有账户与合约账户的比较" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>外部拥有账户与合约账户的比较</h3>
<p>理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p>
<p>不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。我们将会在“交易和消息”部分来了解关于合约与合约之间的通信。</p>
<p><img src="https://i.loli.net/2020/05/27/VdCFt5qL1zQJjGT.png" alt="18.7.png"></p>
<p>因此，在Simplechain上任何的动作，总是被外部控制账户触发的交易所发动的。</p>
<p><img src="https://i.loli.net/2020/05/27/GVbdloOpPKfFmz6.png" alt="18.8.png"></p>
<h3><a class="anchor" aria-hidden="true" id="账户状态"></a><a href="#账户状态" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>账户状态</h3>
<p>账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：</p>
<ol>
<li>nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号</li>
<li>balance： 此地址拥有Wei的数量。1Sipc=10^18Wei</li>
<li>storageRoot： Merkle Patricia树的根节点Hash值（我们后面在解释Merkle树）。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值</li>
<li>codeHash：此账户EVM（Simplechain虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值</li>
</ol>
<p><img src="https://i.loli.net/2020/05/27/yPzXKSTsZ382Mlt.png" alt="18.9.png"></p>
<h2><a class="anchor" aria-hidden="true" id="存储状态"></a><a href="#存储状态" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储状态</h2>
<p>好了，我们知道了Simplechain的全局状态就是由账户地址和账户状态的一个映射组成。这个映射被保存在一个叫做Merkle Patricia树的数据结构中
Merkle Tree（也被叫做Merkle trie）是一种由一系列节点组成的二叉树，这些节点包括：</p>
<ol>
<li>在树底的包含了源数据的大量叶子节点</li>
<li>一系列的中间的节点，这些节点是两个子节点的Hash值</li>
<li>一个根节点，同样是两个子节点的Hash值，代表着整棵树</li>
</ol>
<p><img src="https://i.loli.net/2020/05/27/EDQVY6Igy87FSPk.png" alt="18.10.png"></p>
<p>树底的数据是通过分开我们想要保存到chunks的数据产生的，然后将chunks分成buckets，再然后再获取每个bucket的hash值并一直重复直到最后只剩下一个Hash：根Hash。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74lu363bj30m80c4wf4.jpg" alt="18.11.png"></p>
<p>这棵树要求存在里面的值（value）都有一个对应的key。从树的根节点开始，key会告诉你顺着哪个子节点可以获得对应的值，这个值存在叶子节点。在Simplechain中，key/value是地址和与地址相关联的账户之间状态的映射，包括每个账户的balance, nonce, codeHash和storageRoot（storageRoot自己就是一颗树）。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74luoolmj30m80i5dga.jpg" alt="18.12.png"></p>
<p>同样的树结构也用来存储交易和收据。更具体的说，每个块都有一个头(header)，保存了三个不同Merkle trie结构的根节点的Hash，包括：</p>
<ol>
<li>状态树</li>
<li>交易树</li>
<li>收据树</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74lu37umj30m80fd3z8.jpg" alt="18.13.png"></p>
<p>在Merkle tries中存储所有信息的高效性在Simplechain中的“轻客户端”和“轻节点”相当的有用。广泛的说，有两种节点类型：全节点和轻节点。</p>
<p>全节点通过下载整条链来进行同步，从创世纪块到当前块，执行其中包含的所有交易。通常，矿工会存储全节点，因为他们在挖矿过程中需要全节点。也有可能下载一个全节点而不用执行所有的交易。无论如何，一个全节点包含了整个链。</p>
<p>不过除非一个节点需要执行所有的交易或轻松访问历史数据，不然没必要保存整条链。这就是轻节点概念的来源。比起下载和存储整个链以及执行其中所有的交易，轻节点仅仅下载链的头，从创世纪块到当前块的头，不执行任何的交易或检索任何相关联的状态。由于轻节点可以访问块的头，而头中包含了3个tries的Hash，所有轻节点依然可以很容易生成和接收关于交易、事件、余额等可验证的答案。</p>
<p>这个可以行的通是因为在Merkle树中hash值是向上传播的—如果一个恶意用户试图用一个假交易来交换Merkle树底的交易，这个会改变它上面节点的hash值，而它上面节点的值的改变也会导致上上一个节点Hash值的改变，以此类推，一直到树的根节点。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74lu4802j30m80oe3zg.jpg" alt="18.14.png"></p>
<p>任何节点想要验证一些数据都可以通过Merkle证明来进行验证，Merkle 证明的组成：</p>
<ol>
<li>一块需要验证的数据</li>
<li>树的根节点Hash</li>
<li>一个“分支”（从 chunk到根这个路径上所有的hash值）</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74lu43uzj30m80rawfj.jpg" alt="18.15.png"></p>
<p>任何可以读取证明的人都可以验证分支的hash是连贯的，因此给出的块在树中实际的位置就是在此处。</p>
<p>总之，使用Merkle Patricia树的好处就是该结构的根节点加密取决于存储在树中的数据，而且根据点的hash还可以作为该数据的安全标识。由于块的头包含了状态、交易、收据树的根hash，所有任何节点都可以验证Simplechain的一小部分状态而不用保存整个状态，这整个状态的的大小可能是非常大的。</p>
<h2><a class="anchor" aria-hidden="true" id="gas和费用"></a><a href="#gas和费用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gas和费用</h2>
<p>在Simplechain中一个比较重要的概念就是费用，由Simplechain网络上的交易而产生的每一次计算，都会产生费用。这个费用是以称之为”gas”的来支付。</p>
<p>gas就是用来衡量在一个具体计算中要求的费用单位。gasprice就是你愿意在每个gas上花费Sipc的数量，以“gwei”进行衡量。“Wei”是Sipc的最小单位，1Sipc表示10^18Wei. 1gwei是1,000,000,000 Wei。</p>
<p>对每个交易，发送者设置gaslimit和gasprice。gaslimit和gasprice就代表着发送者愿意为执行交易支付的Wei的最大值。</p>
<p>例如，假设发送者设置gas limit为50,000，gasprice为20gwei。这就表示发送者愿意最多支付50,000*20gwei = 1,000,000,000,000,000 Wei = 0.001 Sipc来执行此交易。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7xug7j30m806l0sx.jpg" alt="18.16.png"></p>
<p>记住gas limit代表用户愿意花费在gas上的钱的最大值。如果在他们的账户余额中有足够的Sipc来支付这个最大值费用，那么就没问题。在交易结束时任何未使用的gas都会被返回给发送者，以原始费率兑换。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7gj07j30m8078aai.jpg" alt="18.17.png"></p>
<p>在发送者没有提供足够的gas来执行交易，那么交易执行就会出现“gas不足”然后被认为是无效的。在这种情况下，交易处理就会被终止以及所有已改变的状态将会被恢复，最后我们就又回到了交易之前的状态—完完全全的之前状态就像这笔交易从来没有发生。因为机器在耗尽gas之前还是为计算做出了努力， 所以理论上，将不会有任何的gas被返回给发送者。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7fkdaj30m8063aab.jpg" alt="18.18.png"></p>
<p>这些gas的钱到底去了哪里？发送者在gas上花费的所有钱都发送给了“受益人”地址，通常情况下就是矿工的地址。因为矿工为了计算和验证交易做出了努力，所以矿工接收gas的费用作为奖励。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7hrv0j30m809l74w.jpg" alt="18.19.png"></p>
<p>通常，发送者愿意支付更高的gas price，矿工从这笔交易总就能获得更多的价值。因此，矿工也就更加愿意选择这笔交易。这样的话，矿工可以自由的选择一笔交易自己愿意验证或忽略。为了引导发送者应该设置gas price为多少，矿工可以选择建议一个最小的gas值他们愿意执行一个交易。</p>
<h3><a class="anchor" aria-hidden="true" id="存储也有费用"></a><a href="#存储也有费用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储也有费用</h3>
<p>gas不仅仅是用来支付计算这一步的费用，而且也用来支付存储的费用。存储的总费用与所使用的32位字节的最小倍数成比例。
存储费用有一些比较细微的方面。比如，由于增加了的存储增加了所有节点上的Simplechain状态数据库的大小，所以激励保持数据存储量小。为了这个原因，如果一个交易的执行有一步是清除一个存储实体，那么为执行这个操作的费用就会被放弃，并且由于释放存储空间的退款就会被返回给发送者。</p>
<h3><a class="anchor" aria-hidden="true" id="费用的作用是什么？"></a><a href="#费用的作用是什么？" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>费用的作用是什么？</h3>
<p>Simplechain可以运作的一个重要方面就是每个网络执行的操作同时也被全节点所影响。然而，计算的操作在Simplechain虚拟机上是非常昂贵的。因此，Simplechain智能合约最好是用来执行最简单的任务，比如运行一个简单的业务逻辑或者验证签名和其他密码对象，而不是用于复杂的操作，比如文件存储，电子邮件，或机器学习，这些会给网络造成压力。施加费用防止用户使网络超负荷。</p>
<p>Simplechain是一个图灵完备语言。这就允许有循环，并使Simplechain受到停机问题的影响，这个问题让你无法确定程序是否无限制的运行。如果没有费用的话，恶意的执行者通过执行一个包含无限循环的交易就可以很容易的让网络瘫痪而不会产生任何反响。因此，费用保护网络不受蓄意攻击。</p>
<h2><a class="anchor" aria-hidden="true" id="交易和消息"></a><a href="#交易和消息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>交易和消息</h2>
<p>之前说过Simplechain是一个基于交易的状态机。换句话说，在两个不同账户之间发生的交易才让Simplechain状态从一个状态转换成另一个状态。</p>
<p>最基本的概念，一个交易就是被外部拥有账户生成的加密签名的一段指令，序列化，然后提交给区块链。</p>
<p>有两种类型的交易：消息通信和合约创建(也就是交易产生一个新的Simplechain合约)。</p>
<p>不管什么类型的交易，都包含：</p>
<ol>
<li>nonce：发送者发送交易数的计数</li>
<li>gasPrice：发送者愿意支付执行交易所需的每个gas的Wei数量</li>
<li>gasLimit：发送者愿意为执行交易支付gas数量的最大值。这个数量被设置之后在任何计算完成之前就会被提前扣掉</li>
<li>to：接收者的地址。在合约创建交易中，合约账户的地址还没有存在，所以值先空着</li>
<li>value：从发送者转移到接收者的Wei数量。在合约创建交易中，value作为新建合约账户的开始余额</li>
<li>v,r,s：用于产生标识交易发生着的签名</li>
<li>init（只有在合约创建交易中存在）：用来初始化新合约账户的EVM代码片段。init值会执行一次，然后就会被丢弃。当init第一次执行的时候，它返回一个账户代码体，也就是永久与合约账户关联的一段代码。</li>
<li>data（可选域，只有在消息通信中存在）：消息通话中的输入数据(也就是参数)。例如，如果智能合约就是一个域名注册服务，那么调用合约可能就会期待输入域例如域名和IP地址</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7g948j30c40e0745.jpg" alt="18.20.png"></p>
<p>在Simplechain状态全局范围内的合约可以与在相同范围内的合约进行通信。他们是通过“消息”或者“内部交易”进行通信的。可以认为消息或内部交易类似于交易，不过与交易有着最大的不同点—它们不是由外部拥有账户产生的。相反，他们是被合约产生的。它们是虚拟对象，与交易不同，没有被序列化而且只存在与Simplechain执行环境。</p>
<p>当一个合约发送一个内部交易给另一个合约，存在于接收者合约账户相关联的代码就会被执行。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7ij9yj30m808jjse.jpg" alt="18.21.png"></p>
<p>一个重要需要注意的事情是内部交易或者消息不包含gasLimit。因为gaslimit是由原始交易的外部创建者决定的（也就是外部拥有账户）。外部拥有账户设置的gaslimit必须要高到足够将交易完成，包括由于此交易而长生的任何”子执行”，例如合约到合约的消息。如果，在一个交易或者信息链中，其中一个消息执行使gas已不足，那么这个消息的执行会被还原，包括任何被此执行触发的子消息。</p>
<h2><a class="anchor" aria-hidden="true" id="区块"></a><a href="#区块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区块</h2>
<p>所有的交易都被组成一个”块”。一个区块链包含了一系列这样的链在一起区块。</p>
<p>在Simplechain中，一个区块包含：</p>
<ol>
<li>区块头</li>
<li>关于包含在此区块中交易集的信息</li>
<li>与当前块的ommers相关的一系列其他区块头</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="ommers解释"></a><a href="#ommers解释" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ommers解释</h3>
<p>“ommer”到底是什么？为什么一个区块需要为ommers包含区块头。</p>
<p>由于Simplechain的构造，它的区块生产时间（大概15秒左右）比其他的区块链例如Bitcoin（大概10分钟左右）要快很多。这使得交易的处理更快。但是，更短的区块生产时间的一个缺点就是：更多的竞争区块会被矿工发现。这些竞争区块同样也被称为“孤区块”（也就是被挖出来但是不会被添加到主链上的区块）。</p>
<p>Ommers的目的就是为了帮助奖励矿工纳入这些孤区块。矿工包含的ommers必须是有效的，也就是ommers必须在父区块的第6个子区块之内或更小范围内。在第6个子区块之后，陈旧的孤区块将不会再被引用。Ommer区块会收到比全区块少一点的奖励。不管怎样，依然存在激励来让矿工们纳入孤区块并能从中获得一些报酬。</p>
<h3><a class="anchor" aria-hidden="true" id="区块头"></a><a href="#区块头" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区块头</h3>
<p>区块头是一个区块的一部分，包含了：</p>
<ol>
<li>parentHash：父区块头的Hash值（这也是使得区块变成区块链的原因）</li>
<li>ommerHash：当前区块ommers列表的Hash值</li>
<li>beneficiary：接收挖此区块费用的账户地址</li>
<li>stateRoot：状态树根节点的Hash值（回忆一下我们之前所说的保存在头中的状态树以及它使得轻客户端认证任何关于状态的事情都变得非常简单）</li>
<li>transactionsRoot：包含此区块所列的所有交易的树的根节点Hash值</li>
<li>receiptsRoot：包含此区块所列的所有交易收据的树的根节点Hash值</li>
<li>logsBloom：由日志信息组成的一个Bloom过滤器 （数据结构）</li>
<li>difficulty： 此区块的难度级别</li>
<li>number：当前区块的计数（创世纪块的区块序号为0，对于每个后续区块，区块序号都增加1）</li>
<li>gasLimit：每个区块的当前gas limit</li>
<li>gasUsed： 此区块中交易所用的总gas量</li>
<li>timestamp：此区块成立时的unix的时间戳</li>
<li>extraData：与此区块相关的附加数据</li>
<li>mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算</li>
<li>nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7n9tqj30m80fd3z8.jpg" alt="18.22.png"></p>
<p>注意每个区块是如何包含三个树结构的，三个树结构分别对应：</p>
<ol>
<li>状态（stateRoot）</li>
<li>交易（transactionsRoot）</li>
<li>收据（receiptsRoot）</li>
</ol>
<p>这三个树结构就是我们前面讨论的Merkle Patricia树。
另外，上面描述的有几个术语值得说明一下，下面来看一下。</p>
<h2><a class="anchor" aria-hidden="true" id="日志"></a><a href="#日志" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>日志</h2>
<p>Simplechain允许日志可以跟踪各种交易和信息。一个合约可以通过定义“事件”来显示的生成日志。
一个日志的实体包含：</p>
<ol>
<li>记录器的账户地址</li>
<li>代表本次交易执行的各种事件的一系列主题以及与这些事件相关的任何数据</li>
</ol>
<p>日志被保存在<code>bloom过滤器</code>中，过滤器高效的保存了无尽的日志数据。</p>
<h2><a class="anchor" aria-hidden="true" id="交易收据"></a><a href="#交易收据" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>交易收据</h2>
<p>自于被包含在交易收据中的日志信息存储在头中。就像你在商店买东西时收到的收据一样，Simplechain为每笔交易都产生一个收据。像你期望的那样，每个收据包含关于交易的特定信息。这些收据包含着：</p>
<ol>
<li>区块序号</li>
<li>区块Hash</li>
<li>交易Hash</li>
<li>当前交易使用了的gas</li>
<li>在当前交易执行完之后当前块使用的累计gas</li>
<li>执行当前交易时创建的日志</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="区块难度"></a><a href="#区块难度" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区块难度</h2>
<p>区块的难度是被用来在验证区块时加强一致性。有一个特殊的公式用来计算之后的每个块的难度。如果某个区块比前一个区块验证的更快，Simplechain协议就会增加区块的难度。区块的难度影响nonce，它是在挖矿时必须要使用proof-of-work算法来计算的一个hash值。</p>
<p>区块难度和nonce之间的关系用数学形式表达就是：</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74t7ltyhj304i036mwy.jpg" alt="18.23.png"></p>
<p>Hd代表的是难度。</p>
<p>找到符合难度阈值的nonce唯一方法就是使用proof-of-work算法来列举所有的可能性。找到解决方案预期时间与难度成正比—难度越高，找到nonce就越困难，因此验证一个区块也就越难，这又相应地增加了验证新块所需的时间。所以，通过调整区块难度，协议可以调整验证区块所需的时间。</p>
<p>另一方面，如果验证时间变的越来越慢，协议就会降低难度。这样的话，验证时间自我调节以保持恒定的速率—平均每15s一个块。</p>
<h2><a class="anchor" aria-hidden="true" id="交易执行"></a><a href="#交易执行" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>交易执行</h2>
<p>假设你发送了一笔交易给Simplechain网络处理，将Simplechain状态转换成包含你的交易这个过程到底发生了什么？</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74wiuxurj30m80c0t9j.jpg" alt="18.24.png"></p>
<p>首先，为了可以被执行所有的交易必须都要符合最基础的一系列要求，包括：</p>
<p>交易必须是正确格式化的RLP。”RLP”代表Recursive Length Prefix，它是一种数据格式，用来编码二进制数据嵌套数组。Simplechain就是使用RLP格式序列化对象。</p>
<p>有效的交易签名。
有效的交易序号。回忆一下账户中的nonce就是从此账户发送出去交易的计数。如果有效，那么交易序号一定等于发送账户中的nonce。
交易的gas limit 一定要等于或者大于交易使用的intrinsic gas，intrinsic gas包括： ——-1.执行交易预订费用为21,000gas ——-2.随交易发送的数据的gas费用（每字节数据或代码为0的费用为4gas，每个非零字节的数据或代码费用为68gas） ——-3.如果交易是合约创建交易，还需要额外的32,000gas</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf74wivddnj30m805q0sz.jpg" alt="18.25.png"></p>
<p>发送账户余额必须有足够的Sipc来支付”前期”gas费用。前期gas费用的计算比较简单：首先，交易的gas limit乘以交易的gas价格得到最大的gas费用。然后，这个最大gas费用被加到从发送方传送给接收方的总值。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf75ku0ucaj31eo0iqgn5.jpg" alt="83.png"></p>
<p>如何交易符合上面所说的所有要求，那么我们进行下面步骤。
第一步，我们从发送者的余额中扣除执行的前期费用，并为当前交易将发送者账户中的nonce增加1。此时，我们可以计算剩余的gas，将交易的总gas减去使用的intrinsic gas。</p>
<p><img src="http://ww1.sinaimg.cn/large/007csy4ply1gf75ay1ocvj30m805rmxl.jpg" alt="18.27.png"></p>
<p>第二步，开始执行交易。在交易执行的整个过程中，Simplechain保持跟踪“子状态”。子状态是记录在交易中生成的信息的一种方式，当交易完成时会立即需要这些信息。具体来说，它包含：</p>
<p>自毁集：在交易完成之后会被丢弃的账户集（如果存在的话）
日志系列：虚拟机的代码执行的归档和可检索的检查点
退款余额：交易完成之后需要退还给发送账户的总额。回忆一下我们之前提到的Simplechain中的存储需要付费，发送者要是清理了内存就会有退款。Simplechain使用退款计数进行跟踪退款余额。退款计数从0开始并且每当合约删除了一些存储中的东西都会进行增加。
第三步，交易所需的各种计算开始被处理。
当交易所需的步骤全部处理完成，并假设没有无效状态，通过确定退还给发送者的未使用的gas量，最终的状态也被确定。除了未使用的gas，发送者还会得到上面所说的“退款余额”中退还的一些津贴。</p>
<p>一旦发送者得到退款之后：</p>
<p>gas的Sipc就会矿工
交易使用的gas会被添加到区块的gas计数中（计数一直记录当前区块中所有交易使用的gas总量，这对于验证区块时是非常有用的）
所有在自毁集中的账户（如果存在的话）都会被删除
最后，我们就有了一个新的状态以及交易创建的一系列日志。
现在我们已经介绍了交易执行的基本知识，让我们再看看合约创建交易和消息通信的一些区别。</p>
<h2><a class="anchor" aria-hidden="true" id="合约创建contract-creation"></a><a href="#合约创建contract-creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合约创建(Contract creation)</h2>
<p>回忆一下在Simplechain中，有两种账户类型：合约账户和外部拥有账户。当我们说一个交易是“合约创建”，是指交易的目的是创建一个新的合约账户。
为了创建一个新的合约账户，我们使用一个特殊的公式来声明新账户的地址。然后我们使用下面的方法来初始化一个账户：</p>
<p>设置nonce为0
如果发送者通过交易发送了一定量的Sipc作为value，那么设置账户的余额为value
将存储设置为0
设置合约的codeHash为一个空字符串的Hash值
一旦我们完成了账户的初始化，使用交易发送过来的init code（查看”交易和信息”章节来复习一下init code），实际上就创造了一个账户。init code的执行过程是各种各样的。取决于合约的构造器，可能是更新账户的存储，也可能是创建另一个合约账户，或者发起另一个消息通信等等。
当初始化合约的代码被执行之后，会使用gas。交易不允许使用的gas超过剩余gas。如果它使用的gas超过剩余gas，那么就会发生gas不足异(OOG)常并退出。如果一个交易由于gas不足异常而退出，那么状态会立刻恢复到交易前的一个点。发送者也不会获得在gas用完之前所花费的gas。</p>
<p>不过，如果发送者随着交易发送了Sipc，即使合约创建失败Sipc也会被退回来。</p>
<p>如果初始化代码成功的执行完成，最后的合约创建的花费会被支付。这些是存储成本，与创建的合约代码大小成正比（再一次，没有免费的午餐）。如果没有足够的剩余gas来支付最后的花费，那么交易就会再次宣布gas不足异常并中断退出。</p>
<p>如果所有的都正常进行没有任何异常出现，那么任何剩余的未使用gas都会被退回给原始的交易发送者，现在改变的状态才被允许永久保存。</p>
<h2><a class="anchor" aria-hidden="true" id="消息通信message-calls"></a><a href="#消息通信message-calls" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息通信(Message calls)</h2>
<p>消息通信的执行与合约创建比较类似，只不过有一点点区别。
由于没有新账户被创建，所以消息通信的执行不包含任何的init code。不过，它可以包含输入数据，如果交易发送者提供了此数据的话。一旦执行，消息通信同样会有一个额外的组件来包含输出数据，如果后续执行需要此数据的话就组件就会被使用。</p>
<p>就像合约创建一样，如果消息通信执行退出是因为gas不足或交易无效（例如栈溢出，无效跳转目的地或无效指令），那么已使用的gas是不会被退回给原始触发者的。相反，所有剩余的未使用gas也会被消耗掉，并且状态会被立刻重置为余额转移之前的那个点。</p>
<p>没有任何方法停止或恢复交易的执行而不让系统消耗你提供的所有gas，直到最新的Simplechain更新。例如，假设你编写了一个合约，当调用者没有授权来执行这些交易的时候抛出一个错误。在Simplechain的前一个版本中，剩余的gas也会被消耗掉，并且没有任何gas退回给发送者。但是拜占庭更新包括了一个新的“恢复”代码，允许合约停止执行并且恢复状态改变而不消耗剩余的gas，此代码还拥有返回交易失败原因的能力。如果一个交易是由于恢复而退出，那么未使用的gas就会被返回给发送者。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/sipc-docs/docs/docs_17"><span class="arrow-prev">← </span><span>虚拟机</span></a><a class="docs-next button" href="/sipc-docs/docs/docs_19"><span>异常处理</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#simplechain模型说明">Simplechain模型说明</a></li><li><a href="#账户">账户</a><ul class="toc-headings"><li><a href="#外部拥有账户与合约账户的比较">外部拥有账户与合约账户的比较</a></li><li><a href="#账户状态">账户状态</a></li></ul></li><li><a href="#存储状态">存储状态</a></li><li><a href="#gas和费用">Gas和费用</a><ul class="toc-headings"><li><a href="#存储也有费用">存储也有费用</a></li><li><a href="#费用的作用是什么？">费用的作用是什么？</a></li></ul></li><li><a href="#交易和消息">交易和消息</a></li><li><a href="#区块">区块</a><ul class="toc-headings"><li><a href="#ommers解释">Ommers解释</a></li><li><a href="#区块头">区块头</a></li></ul></li><li><a href="#日志">日志</a></li><li><a href="#交易收据">交易收据</a></li><li><a href="#区块难度">区块难度</a></li><li><a href="#交易执行">交易执行</a></li><li><a href="#合约创建contract-creation">合约创建(Contract creation)</a></li><li><a href="#消息通信message-calls">消息通信(Message calls)</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/sipc-docs/" class="nav-home"></a><div><h5>文档</h5><a href="/sipc-docs/docs/en/doc1.html">快速开始</a><a href="/sipc-docs/docs/en/doc2.html">引导</a><a href="/sipc-docs/docs/en/doc3.html">API接口</a></div><div><h5>社区</h5><a href="/sipc-docs/en/https://t.me/SimpleChainOfficial">Telegram</a><a href="https://medium.com/@SimpleChain" target="_blank" rel="noreferrer noopener">Medium</a><a href="https://twitter.com/SimpleChain">Twitter</a><a href="https://www.linkedin.com/company/simplechain-foundation/" target="_blank" rel="noreferrer noopener">Linkedln</a></div><div><h5>更多</h5><a href="https://www.simplechain.com">官网</a><a href="https://github.com/simplechain-org">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2020 SimpleChain Community</section></footer></div></body></html>