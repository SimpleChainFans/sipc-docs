---
id: docs_5
title: 快速搭建
sidebar_label: 快速搭建
---

### Docker搭建


### HomeBrew 搭建


### 安装包搭建


### 源码搭建

一、SimpleChain 安装与部署
下载与安装 sipe
前期准备:Go 语言环境(1.10 或以上版本)、C 语言编译器
1.下载 SimpleChain
可以通过 git 将项目 clone 到本地，也可以在 https://github.com/simplechain-org/go-
simplechain 页面直接下载。
git clone https://github.com/simplechain-org/go-simplechain.git 2.安装 sipe
1)进入 go-simplechain 根目录。
cd go-simplechain
2)使用 make 工具安装 sipe。
 
 
 
 
 
make sipe
>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core
...
github.com/simplechain-org/go-simplechain/cmd/sipe
Done building.
Run "/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe" to launch sipe.
当终端出现以上输出时，表示 make 执行成功，此时在 go-simplechain/build/bin 目录下 将会生成 sipe 可执行文件。可以将其移动到任何目录下或将其加入到环境变量中，以此 来便利得运行 sipe 程序。
启动 sipe
1.创建用于存储节点数据的文件夹 mkdir chaindata
2.启动 sipe 主网节点
开启 RPC 服务并指定 RPC 监听地址为 127.0.0.1，端口 8545。节点数据存储目录为 chaindata
       sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata 当出现类似以下输出时，表示启动成功，并开始同步 SimpleChain 主网区块。
3.启动 sipe 控制台 新建终端窗口，通过以下命令开启一个连接到此节点的交互控制台。 sipe attach chaindata/sipe.ipc
4.创建账户
在启动的控制台下使用以下命令创建一个账户。
创建成功后，控制台会返回账户地址，同时会在 chaindata/keystore 生成账户的 json 文 件，此文件可以通过密码解析获得账户私钥。
5.启用挖矿
重启 sipe 节点，启用挖矿，指定矿工地址为你创建的账户地址，挖矿线程数为 1。
当然，你也可以通过控制台指定矿工地址并开启挖矿。
搭建 SimpleChain 测试网络
1.创建创世块文件
新建文件 genesis.json，内容如下。 {
         INFO [06-19|09:35:01.481] Maximum peer count
INFO [06-19|09:35:01.492] Starting peer-to-peer node 0cbf2a41/darwin-amd64/go1.12.1
...
INFO [06-19|09:35:33.700] Block synchronisation started
INFO [06-19|09:35:36.756] Imported new block headers elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0
ETH=25 LES=0 total=25 instance=Sipe/v1.0.2-stable-
count=192
                              > personal.newAccount()
Passphrase:
Repeat passphrase: "0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd" //账户地址
               sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata --mine --minerthreads=1 --
   etherbase=0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd
         > miner.setEtherbase('0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd') > miner.start()
           
    "config": {
"chainId": 100, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0
},
"alloc" : {},
"coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x20000",
"extraData" : "",
"gasLimit" : "0x2fefd8",
"nonce" : "0x0000000000000042",
"mixhash" :
                           "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" :
"0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"
}
           其中 chainId 为此测试网络的 ID，主网的 ID 为 1，difficulty 为挖矿难度，为方便测试 网络的运行，难度设置较低。
2.启动节点一
1)创建节点一的存储目录 nodedata1。
mkdir nodedata1
2)使用 genesis.json 初始化节点一的创世区块。
sipe init --datadir nodedata1 genesis.json
3)启动节点，指定 networkid，节点通信时须保证指定的 networkid 相同。
4)在开启的控制台中查看节点信息，获取本节点 enode。
                        sipe --datadir nodedata1 --port 30312 --rpc --rpcaddr 127.0.0.1 --rpcport 8541 --networkid 10001 console
           > admin.nodeInfo {
enode:
"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@[::]:30312",
id: "05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110",
ip: "::",
listenAddr: "[::]:30312",
name: "Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1", ports: {
                        discovery: 30312,

    listener: 30312 },
protocols: { eth: {
config: { chainId: 100, eip150Hash:
"0x0000000000000000000000000000000000000000000000000000000000000000", eip155Block: 0,
eip158Block: 0,
homesteadBlock: 0 },
difficulty: 131072,
                           genesis: "0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0", head: "0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0", network: 10001
} }
}
             3.启动节点二
1)创建节点一的存储目录 nodedata2。
mkdir nodedata2
2)使用 genesis.json 初始化节点一的创世区块。
sipe init --datadir nodedata2 genesis.json
3)启动节点，保证 networdid 与节点一相同，注意配置 bootnodes 时将节点一获取的 enode 的[::]替换为节点一的 IP 地址，即 127.0.0.1。
4)查看关联节点信息，返回结果不为空即确认节点二与节点一连接成功。
                        sipe --datadir nodedata2 --port 30313 --rpc --rpcaddr 127.0.0.1 --rpcport 8542 --networkid 10001 --bootnodes "enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@127.0.0.1:30312"
         console
         > admin.peers [{
caps: ["eth/63"],
id: "05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110",
name: "Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1", network: {
inbound: false,
localAddress: "127.0.0.1:58388", remoteAddress: "127.0.0.1:30312",
                    
    static: false,
trusted: false },
protocols: { eth: {
difficulty: 131072,
head: "0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0", version: 63
} }
}]
                       3.在测试网络中挖矿 1)在节点一创建账号，并将其设置为矿工地址。
2)在节点一启动挖矿。
      > personal.newAccount()
Passphrase:
Repeat passphrase:
"0x7f53309f95559c52d08f18724c0b24aa758d1953"
> miner.setEtherbase('0x7f53309f95559c52d08f18724c0b24aa758d1953') true
                   > miner.start()
INFO [06-19|10:53:15.918] Updated mining threads threads=0
INFO [06-19|10:53:15.918] Transaction pool price threshold updated price=1000000000 INFO [06-19|10:53:15.918] Starting mining operation
null
> INFO [06-19|10:53:15.918] Commit new mining work
elapsed=207.516μs
INFO [06-19|10:53:47.601] Successfully sealed new block
hash=755f08...62e560
INFO [06-19|10:53:47.607] 🔨 mined potential block
hash=755f08...62e560
          number=1 txs=0 uncles=0 number=1
        number=1
     3)在节点二确认同步区块。
      INFO [06-19|10:53:49.246] Block synchronisation started
INFO [06-19|10:53:49.538] Imported new block headers count=2 elapsed=6.482ms number=2 hash=c7c0a9...79db3e ignored=0
INFO [06-19|10:53:49.539] Imported new chain segment blocks=2 txs=0 mgas=0.000 elapsed=766.945μs mgasps=0.000 number=2 hash=c7c0a9...79db3e cache=1.20kB
INFO [06-19|10:53:49.556] Imported new state entries count=3 elapsed=90.308μs processed=3 pending=0 retry=0 duplicate=0 unexpected=0
INFO [06-19|10:53:49.601] Fast sync complete, auto disabling
INFO [06-19|10:53:59.119] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=1.212ms mgasps=0.000 number=3 hash=6dd8b2...194509 cache=1.81kB
                     4.在测试网络中转账

 1)使用控制台创建另一个账户。
      > personal.newAccount()
Passphrase:
Repeat passphrase: "0xf9143e3b7de8ce91e463e30480f5afe84d3067ba"
         2)转账前使用密码解锁转账人账户。
3)发送交易进行转账，其中 from 为转账人，这里是矿工地址，to 为收款人，value 是转 账额度。
4)确认到账。
二、如何在 SimpleChain 上发币
本章旨在通过一个简单的链上发币 demo，向开发者展示合约的部署与执行，帮助开发 者了解合约，为开发者后续的链上开发打下基础。
前提条件
实现链上发币的准备工作，包括:
1. SimpleChain 的下载以及部署。 2. 启动节点。
3. 创建账户。
4. 确保账户解锁并有 token。
准备工作
1. 了解 ERC20 代币标准。
说明:在 SimpleChain 上实现代币需要遵循 ERC20 标准。
      > personal.unlockAccount('0x7f53309f95559c52d08f18724c0b24aa758d1953') Unlock account 0x7f53309f95559c52d08f18724c0b24aa758d1953
Passphrase:
       true
         > eth.sendTransaction({from:"0x7f53309f95559c52d08f18724c0b24aa758d1953",to:"0xf9143e 3b7de8ce91e463e30480f5afe84d3067ba",value:web3.toWei(10,"ether")}) "0x5a6fbb3161329ca2591b7ecbcaca8a15a94cac5d402fce929f24504c76b8b7bb"
               > eth.getBalance('0xf9143e3b7de8ce91e463e30480f5afe84d3067ba') 10000000000000000000
             //ERC20Token.sol
//ERC 合约标准，该标准规定在发 Token 之前，需要指定 token 的名称、标
识、总量、实现合 //约标准函数等
      
    pragma solidity ^0.4.26; contract ERC20Token {
//获取 token 名称
function name() public constant returns (string name);
//获取 token 标识
function symbol() public constant returns (string symbol);
//获取 token 的最小分割量
function decimals() public constant returns (uint8 decimals);
                   //获取 token 的总量
function totalSupply() public constant returns (uint256 totalSupply);
//获取_owner 账户当前的 token 量
function balanceOf(address _owner) public constant returns (uint256 balance);
//转账交易
function transfer(address _to, uint256 _value) public returns (bool success);
//由_from 向_to 进行转账
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
//许可_spender 能从调用合约方法的账户转出总量为_value 的 token
function approve(address _spender, uint256 _value) public returns (bool success);
//获取_spender 可以从账户_owner 中转出 token 的剩余数量
function allowance(address _owner, address _spender) public constant returns (uint remaining);
                                     //转账事件(transfer、transferFrom 会触发该事件)
event Transfer(address indexed _from, address indexed _to, uint256 _value);
//许可事件(approve 会触发该事件)
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
              2. 编写符合 ERC20 标准的代币合约。
      //Mytoken.sol
pragma solidity ^0.4.26;
  
      import "./ERC20Token.sol";
contract MyToken is ERC20Token {
string private _name;
string private _symbol;
uint8 private _decimals = 18; //此处建议为 18，代表最小单位为 0.1^18 uint256 private _totalSupply;
                 //存储账户的 token 总量
mapping(address => uint256) private _balances;
//存储前一个 address 允许后一个 address 转出 token 的剩余数量 mapping(address => mapping(address => uint256)) private _allowances;
function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public{
_name = tokenName;
_symbol = tokenSymbol;
_totalSupply = initialSupply * 10 ** uint256(_decimals); _balances[msg.sender] = _totalSupply;
}
function name() public constant returns (string name){ name = _name;
}
                                   function symbol() public constant returns (string symbol){ symbol = _symbol;
}
function decimals() public constant returns (uint8 decimals){ decimals = _decimals;
}
function totalSupply() public constant returns (uint256 totalSupply){ totalSupply = _totalSupply;
                  
    }
function balanceOf(address _owner) public constant returns (uint256 balance){ balance = _balances[_owner];
}
function transfer(address _to, uint256 _value) public returns (bool success){ require(_balances[msg.sender] >= _value); //保证发出交易的账户 token 足
够完成转账
                   _balances[msg.sender] -= _value; _balances[_to] += value; Transfer(msg.sender, _to, _value); success = true;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
require(_balances[_from] >= _value); //保证_from 账户 token 足够完成转 账
require(_allowances[_from][msg.sender] >= _value); //保证_from 账户允许 执行账户转出的 token 剩余量足够
_balances[_from] -= _value; _allowances[_from][msg.sender] -= _value; _balances[_to] += _value;
Transfer(_from, _to, _value);
success = true;
                                   }
//许可_spender 能从调用合约方法的账户转出总量为_value 的 token
function approve(address _spender, uint256 _value) public returns (bool success){
_allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); success = true;
}
                  
    //获取_spender 可以从账户_owner 中转出 token 的剩余数量
function allowance(address _owner, address _spender) public constant returns (uint256 remaining){
remaining = _allowances[_owner][_spender]; }
}
              合约编译
1. 使用浏览器打开 Remix Solidity IDE。
2. 将 ERC20Token.sol 和 MyToken.sol 添加到 browser 文件夹下。
3. 在网页右侧框选中 Compile 选项，选择合约编译器的版本(本文选择 0.4.26)。
4. 点击 Start to compile 进行编译。
合约部署
1. 选中 Run 选项，在 Environment 中选择 Web3 Provider。在弹出的选框中输入当前启 动的 sipe 节点端口。
2. 选择已解锁且有 token 的 Account 地址。
3. 选择 MyToken 合约，在 Deploy 栏中输入初始化参数:token 总量，token 名，token
标识，点击 Deploy。
4. 等待一分钟左右至合约部署完成，在 Deployed Contracts 栏出现合约则说明部署完
成。至此发币完成。
    
  合约验证
1. 执行合约的 decimals，name，symbol，totalSupply 方法查看代币是否创建成功。
 
 2. 执行 transfer 方法，展开 transfer 方法向其他账户进行转账并使用 balanceOf 查询是 否转账成功。


