---
id: docs_69
title: 交易合法性验证
sidebar_label: 交易合法性验证
---

交易验证是保证`bytom`长期稳定运行和持续发展的重要方式，`bytom`程序中提供了一种十分安全的交易验证机制。

交易验证主要用在以下几个场景中: 

- 用户完成一笔交易的签名时，需要将交易提交到区块链网络中，使交易能够尽快确认节点在提交交易之前，需要先验证交易，确认交易的合法性。- 节点收到其他节点广播的交易时，节点需要先验证交易是否合法，合法的交易才会加人节点的交易池。 
- 当一个挖矿节点成功计算出符合要求的哈希值后，节点会将交易池中的交易打包到区块中。
- 节点在打包交易的时候需要验证交易的合法性。 
- 节点收到其他节点同步的区块时，也需要一一验证区块中包含的交易。

## 验证交易合法性 

1. 验证交易版本号、交易size大小、timerange、是否为标准交易等（validation.ValidateTx）
2. 验证交易输入和输出，并对spend/issue类型的输入执行虚拟机验证（checkValid）。这个里面流程比较多，建议看代码来分解，其验证的内容包括交易输入输出金额是否平衡、先验证BTM资产的手续费的输入输出、交易状态是否合法、执行虚拟机gas的更新等等

## 标准交易

当一笔交易中所有output的锁定脚本都是`bytom`所支持的类型，那么这笔交易就是标准交易。

`bytom`的锁定脚本主要有三种: P2WPKHScript (单签脚本)、P2WSHScript (多签 脚本)和Straightforward (销毁资产的脚本)。
标准P2WPKHScript脚本必须是以`0014`开头的，00对应的是BVM的OP_0操作，该操作会将一个空字符串压人BVM栈。14对应的是〇P_DATA_20操作，该操作会将紧随其后的20个数压人BVM找。 

标准的P2WSHScript则必须是以0020开头的，00对应的操作同P2WPKHSCript脚本相同，20对应的是OP_DATA_32操作，该操作会将紧随其后的32个数压人BVM栈中。 

Straightforward脚i只有两类:一类脚本内容为6a，对应的操作为OP_FAIL，代表这个脚本会无条件执行失败。还有一类是51，对应的操作会将数字1压入BVM栈。

## 交易验证流程

交易雁阵的流程如下：(源码位置：protocol/tx.go和protocol/validation/tx.go)

1. 验证交易是否被处理过（hasSeenTx），如果已经被处理过则直接抛掉，否则添加到cache中（markTransactions）

2. 根据交易ID查询节点的交易池中是否已经存在相同的交易。如果交易池中存在相同的交易，则交易验证不通过，返回ErrCode错误。示例代码如下：

       if ok := c.txPool.HaveTransaction(&tx.ID);ok {
          return false, c.txPool.GetErrCache(&tx.ID)
       }

3.  验证交易的版本和区块的版本是否对应，目前比原链中交易版本号和区块的版本号都是1，版本号的验证主要目的是防止后期`Bytom`出现硬分叉时，导致低版本的交易被错误地打包到高版本的区块中。源码示例如下:

        if block.Version ==1 && tx.Version != 1 {
          return gasStatus,errors.WithDetailf(ErrTxVersion, "block version %d, transaction version %d", block.Version, tx.Version)
        }    

4. 验证交易序列化后的字节数组长度。如果序列化后交易信息的长度等于0，说明这个交易在序列化时出现了未知错误。要做到这个交易即使广播出去，其他节点也无法反序列化获取交易的正确内容。源码示例如下:

       if tx.SerializedSize == 0 {
          return gasStatus.ErrWrongTransactionSize
       }

5. 验证交易的TimeRange,在TimeRange指定的高度，交易仍然没有被打包到区块中，交易会自动作废。如果交易的TimeRange比交易提交时间的区块高度还小，那么这笔交易创建是就是一笔过期交易，永远也不会打包到交易中。因此，需要将这种没有实际意义的交易过滤掉。源码示例如下：
 
       if err := checkTimeRange(tx,block); err != nil {// TimeRange >= block
           return gasStatus,err
       }

6. 验证交易是否是一个标准交易，源码示例如下：

       if err := checkStandardTx(tx); err != nil{
          return gasStatus,err
       }

## 验证交易UTXO

验证交易UTXO是核心验证流程，即验证交易花费的每一个BUTXO是否合法。交易的核心验证流程由protocol/validation/tx.go文件下的checkValid方法实现。

交易验证的两个核心原则：

- 等价交易：各种资产输入和输出的总量必须相等
- 权限验证：对于spend类型的输入，用户提供的解锁脚本要正确的

在交易验证之前，系统会调用MapTx方法将protocol/by/type 包下的交易数据结构转化为protocol/bc 包下的Entry类型。因此，checkValid方法验证交易其本质就是验证每一个Entry类型是否满足交易验证的两个核心原则。说明如下：

- bc.TxHeader Entry 验证。bc.TxHeader是checkValid方法验证交易的入口。bc.TxHeader中记录了交易中其他   Entry类型的信息，在验证过程中会递归验证其中记录的其他Entry类型。
- bc.Output和bc.Retirement Entry验证。使用checkValidSrc方法验证bc.Output或bc.Retirement与Mux之间的对应关系是否正确，并且验证资产的数量是否相等。
- bc.Coinbase Entry验证。由于Coinbase交易是创币交易，比原链中的创币交易只能产生BTM，因此bc.Coinbase验   证时，首先需要保MapTx时，bc.Coinbase导入到Mux中的资产类型一定是BTM资产，并且还要检查Coinbase交易的附带标注信息最多不能超过128个字符。之后就是使用checkValidDest保证Coinbase与导入到Mux上的资产数量相等。
- bc.Issuance和bc.Spend Entry 验证。Issuance和Spend在交易时需要提供资产所有权证明。因此，交易验证时首先要做的就是验证用户提供的资产所有权证明，即验证比原链中解锁脚本是否合法。比原链使用BTM虚拟机验证用户的解锁脚本是否合法。比原链使用BVM虚拟机验证用户的解锁脚本。
- bc.Mux Entry验证。在上面四种类型验证过程中，通过checkValidSrc 保证了Mux与交易输出bc.Output，bc.Retirement之间的资产数量相等；通过checkValidDest保证了交易输入bc.Issuance,bc.Spend和bc.CoinBase与Mux上的资产数量相等。checkValidSrc和checkValidDest验证，只是保证了每一个输入或输出Mux中对应的Sources和WitnessDestinations之间价值相等，但是无法保证每种资产输入和输出的价值相等。因此Mux验证的主要内容是，保证每种资产输入和输出的资产数量相等。checkValidSrc和checkValidDest验证，只是保证了每一输入或输出Mux中对应的Source和WintessDestination之间价值相等，但是无法保证美中资产输入与输出的价值相等。因此Mux验证的主要内容是，保证每种资产输入与输出的资产数量相等。

