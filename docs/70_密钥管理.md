---
id: docs_70
title: 密钥管理
sidebar_label: 密钥管理
---

## ChainKD

比原链确定性密钥派生方案，由两个使用不同哈希函数的实例组成：

**ChainKD2：** 哈希函数为SHA2-512（如EdDSA规范中所示）

**ChainKD3：** 哈希函数为SHA3-512

**特征：**

- 该方案已经完全确定，可以从一个高熵种子（high-entropy seed）生成结构复杂的密钥。
- 使用“强化派生”从扩展私钥派生私钥
- 使用“非强化派生”私钥独立派生公钥。
- 强化公钥、非强化公钥和签名与EdDSA规范兼容。
- 用字节长度可变的串选择符（selector），而不是固定长度的整型索引。
- 没有特殊编码的短64字节扩展公钥和私钥。
- 没有元数据：扩展密钥仅携带额外的32字节的盐值，以避免派生函数仅依赖于密钥本身。
- 隐私：扩展密钥既不显示其在层次结构中的位置，也不显示派生的方式（强化或非强化）。

**定义**

- **Hash512**：具有512比特输出（SHA2-512或SHA3-512）的加密哈希函数，
- **选择符**：字节长度可变的字符串，可以用作派生索引
- **秘密标量**：32字节的字符串，表示使用小端字节序排列的256比特整型
- **公钥** ：32字节的字符串，表示椭圆曲线Ed25519 RFC 8032上的一个点
- **扩展私钥**（xprv）：64字节的字符串，表示可用于派生子扩展私钥和公钥的密钥
- **扩展公钥**（xpub）：64字节的字符串，表示可用于派生子扩展公钥的密钥
- **LEB128**：用小端字节序Base-128编码的无符号整型，用于可变长度选择符字符串的长度前缀。

**安全**

种子或根扩展私钥：

- 可派生强化扩展私钥
- 可派生非强化扩展私钥
- 可使用根密钥签名信息

扩展私钥：

- 可派生强化扩展私钥
- 可派生非强化扩展私钥
- 可使用根密钥签名信息

扩展公钥：

- 可派生非强化公钥
- 无法确定它是以强化还是非强化方式派生的
- 无法确定另一个扩展公钥是否与该密钥同级
- 无法签名
- 无法派生私钥
- 无法派生强化公钥

父级扩展公钥和非强化派生扩展私钥：

- 可提取父私钥：`s = (s' - f) mod L`，其中`f`是从父`xpub`派生，`s'`从子`xprv'`提取。

## 生成

### 生成根密钥

**输入：**

`seed`: 种子字节序列（变量长度，至少256比特随机数）

**输出：**

`xprv`: 扩展私钥

**计算：**

1. 计算`I = Hash512("Chain seed" || seed)`
2. 把I分成两部分：32字节的`buf`和32字节的`salt`
3. 从缓冲器`buf`中[生成秘密标量](#生成秘密标量)`s`
4. 假设`privkey`是用32字节字符串以小端字节序编码的标量`s`
5. 返回`xprv = privkey || salt`（64字节）

### 生成扩展公钥

**输入：**

`xprv`: 扩展私钥。

**输出：**

`xpub`: 扩展公钥。

**计算：**

1. 把xprv分成两部分：32字节的`privkey`和32字节的`salt`
2. 私钥`privkey`是256比特整型s转成小端字节序
3. 做固定基标量乘算法`P = s*B`，其中`B`是Ed25519的基点
4. [编码](#编码公钥)点`P`作为`pubkey`
5. 返回扩展公钥`xpub = pubkey || salt`（64字节）

### 衍生强化扩展私钥

**输入：**

`xprv`: 扩展私钥

`selector`: 字节长度可变的序列用作派生金钥

**输出：**

`xprv`: 派生强化扩展公钥

**计算:**

1. 把`xprv`分成两部分：32字节的`privkey`和32字节的`salt`。
2. 使`len`为`selector`的字节长度。
3. 使`I = Hash512(0x00 || privkey || salt || LEB128(len) || selector)`。
4. 把`I`分成两部分：32字节的`buf`和32字节的`salt'`。
5. 从缓冲器`buf`中[生成秘密标量](#生成秘密标量)`s'`。
6. 假设`privkey'`是用32字节字符串以小端字节序编码的标量`s'`。
7. 返回`xprv' = privkey' || salt'`。

### 衍生非强化扩展私钥

**输入：**

`xprv`:扩展私钥

`selector`: 字节长度可变的序列用作派生金钥

**输出：**

`xprv`: 派生强化扩展公钥

**计算：**

1. 把`xprv`分成两部分：32字节的`privkey`和32字节的`salt`
2. 使`s`为从`privkey`以以小端字节序解码的标量
3. 做固定基标量乘算法`P = s*B`，其中`B`是Ed25519的基点
4. [编码](#编码公钥)点`P`作为`pubkey`
5. 使`len`为`selector`的字节长度
6. 使`I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`
7. 把`I`分成两部分：32字节的`fbuffer`和32字节的`salt'`
8. 从缓冲器`fbuffer`中[生成秘密标量](#生成秘密标量)`f`
9. 计算衍生秘密标量`s' = (f + s) mod L`（其中L代表B的阶）
10. 假设`privkey'`是用32字节字符串以小端字节序编码的标量`s'`
11. 返回`xprv' = privkey' || salt'`

### 派生非强化扩展公钥

**输入：**

`xpub`: 扩展公钥

`selector`:字节长度可变的序列用作派生金钥

**输出：**

`xpub`，派生强化扩展公钥

**计算：**

1. 把`xpub`分成两部分：32字节的pubkey和32字节的`salt`
2. 使`len`为`selector`的字节长度
3. 使`I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`
4. 把`I`分成两部分：32字节的`fbuffer`和32字节的`salt'`
5. 从缓冲器`fbuffer`中[生成秘密标量](#生成秘密标量)`f`
6. 做固定基标量乘算法`F = f*B`，其中`B`是Ed25519的基点
7. 根据EdDSA从`pubkey`解码点`P`
8. 做点加法`P' = P + F`
9. [编码](#编码公钥)点`P'`作为`pubkey'`
10. 返回`xpub' = pubkey' || salt'`

## Keystore文件

Keystore的本质是加密后的私钥，Keystore必须配合你的钱包密码来使用。

**Keystore文件数据结构**

| 字段 | 类型 | 描述 | 
| --- | --- |--- |
|ID | uuid.UUID |   用户 uid |
|KeyType | string | 私钥类型  |
|Alias |	string	|  账户别名 |
|XPrv | chainkd.XPrv |公钥|
|XPub | chainkd.XPub |  私钥  |

## 签名

### 签名

**输入：**

`xprv`: 扩展私钥。

`message`: 表示待签名的信息的字节长度可变的序列

**输出：**

`(R,S)`: 表示EdDSA签名的64字节字符串

**计算：**

1. 拆分`xprv`为两个部分：32字节`privkey`和32字节`salt`
2. 假设`s`是`privkey`使用小端字节序解码的标量
3. 让`h = Hash512(0x02 || privkey || salt)`
4. 假设`prefix`是`h`的前半部分：`prefix = h[0:32]`
5. 执行固定基数标量乘法`P = s*B`，其中`B`是Ed25519的基点
6. 将点`P`[编码](#编码公钥)为`pubkey`
7. 计算`Hash512(prefix || message)`将64字节digest密文转成小端字节序排列的整型`r`
8. 计算点`r*B`。 为了提高效率，用先做`r`模`L`降低计算复杂度，其中L是`B`的阶（group order）
9. 令字符串`R`为点`r*B`的[编码](#编码公钥)
10. 计算`Hash512(R || pubkey || message)`并将64字节digest密文转成小端字节序排列的整型`k`
11. 计算`S = (r + k * s) mod L`。为了提高效率，再次先做`k`模`L`。
12. 将`R`（32字节）和小端字节序编码的`S`（32个字节，最后一个字节的三个最高有效位始终为零）合并
13. 返回`(R,S)`（64字节）

### 验证签名

**输入：**

`xprv`: 扩展公钥

`message`: 表示已签名的信息的字节长度可变的序列

`(R,S)`: 64字节签名

**输出：**

判断签名是否有效的布尔值（boolean value）

**计算：**

1. 提取公钥`pubkey`作为`xpub`的前32字节。
2. 根据[RFC 8032]使用`pubkey`并把Hash512替换SHA512哈希函数
，验证`message`上的验证EdDSA签名`(R,S)`（ChainKD-SHA2实例中，Hash512等于SHA512，从而保证验证过程与EdDSA完全兼容）

### 生成秘密标量

**输入：**

`buffer`: 32字节字符串。

**输出：**

`s`: 256比特整型

**计算:**

1. 修剪缓冲器`buffer`：第一个字节的最低3位被清除，最末字节的最高位被剪除，最末字节的第二高位被设定
2. `buffer`被设作小端字节序整型，形成标量`s`
3. 返回`s`

### 编码公钥

**输入：**

`P`: Ed25519曲线的点

**输出：**

`pubkey`: 32字节字符串代表一个Ed25519曲线的点

**计算：**

1. 首先，将纵坐标（y coordinate）编码（在0 <= y < p的范围内）成32字节的小端字节序字符串。最末字节的最高有效位始终为零
2. 将横坐标（x coordinate）的最末位字节的最低有效位复制给最高有效位，形成点`P`的编码
3. 返回产生的32字节字符串记作`pubkey`
