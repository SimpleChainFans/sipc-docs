<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>共识机制 · SimpleChain开发文档</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="共识机制是区块链事务达成分布式共识的算法。由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制。"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="共识机制 · SimpleChain开发文档"/><meta property="og:type" content="website"/><meta property="og:url" content="https://simplechain.github.io/sipc-docs/"/><meta property="og:description" content="共识机制是区块链事务达成分布式共识的算法。由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制。"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/sipc-docs/"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/sipc-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/sipc-docs/css/main.css"/><script src="/sipc-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/sipc-docs/"><h2 class="headerTitle">SimpleChain开发文档</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_1" target="_self">文档</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_25" target="_self">API</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_50" target="_self">FAQ</a></li><li class="siteNavGroupActive"><a href="/sipc-docs/docs/docs_51" target="_self">在线技术支持</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>底层核心技术</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">快速了解</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_1">概述</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_2">快速开始</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_3">搭建节点</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">sipc和sipc代币协议</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_52">技术术语</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_4">sipc代币</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_5">在SIPC上发行代币</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">基础数据结构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_6">配置</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_7">创世块</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_8">账户</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_9">交易</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_10">区块</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_11">交易回执</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_12">SimpleChain架构设计</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_13">数据结构和存储</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_55">数据同步优化</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">底层核心技术</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_15">P2P网络</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/sipc-docs/docs/docs_16">共识机制</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_17">虚拟机</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_18">运行机制</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_19">异常处理</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">智能合约</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_20">智能合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_21">深入理解Solidity</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_22">合约模版</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_23">合约开发和部署</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发者工具</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_24">搭建测试链</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_25">Sipc API</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_26">跨链API</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_27">SimPlug</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_28">sdk</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">跨链</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_53">跨链方案</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_30">子链模版</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_54">跨链流程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Dapp开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_31">合约编译器</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_32">编写合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_33">发布合约</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_34">开发流程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">挖矿</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_35">Sipc挖矿</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_36">矿池接入</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_37">GPU挖矿</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_38">SimPool</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_39">SimpleNode x1挖矿教程</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_40">SIPC.VIP</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_41">Sipc全节点钱包</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_42">ChainBox</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_43">区块链浏览器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">生态</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_44">交易所对接</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_45">社区项目</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_46">社区活动</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_47">社区入口</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">落地方案</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_48">落地案例</a></li><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_49">构建应用</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">FAQ</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_50">FAQ</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">技术支持</h3><ul class=""><li class="navListItem"><a class="navItem" href="/sipc-docs/docs/docs_51">在线技术支持</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">共识机制</h1></header><article><div><span><p>共识机制是区块链事务达成分布式共识的算法。由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制。</p>
<h2><a class="anchor" aria-hidden="true" id="pow共识算法"></a><a href="#pow共识算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PoW共识算法</h2>
<p>PoW 即通过工作结果来证明你完成了相应的工作哈希函数的特征：</p>
<ol>
<li>免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况。</li>
<li>隐匿性，即给定一个散列值，想要反向逆推出输入值，在计算上是不可行的。</li>
<li>不存在比穷举更好的方法，以使得散列值落在特定的范围。POW算法原理：节点通过不断地更换随机数来探寻合适的哈希值，当节点最先计算出合适的哈希值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中。</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="scrypt算法简介"></a><a href="#scrypt算法简介" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scrypt算法简介</h3>
<p>Simplechain 采用的挖矿算法是Scrypt算法。Scrypt是内存依赖型的POW算法，它是一种符合PoW共识机制的算法。Scrypt算法过程中也需要计算哈希值，但是，Scrypt计算过程中需要使用较多的内存资源。</p>
<h3><a class="anchor" aria-hidden="true" id="scrypt算法过程"></a><a href="#scrypt算法过程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scrypt算法过程</h3>
<p>Scrypt算法使用的几个函数环环相扣，本节按函数从里到外的调用顺序描述。</p>
<h4><a class="anchor" aria-hidden="true" id="salsa208"></a><a href="#salsa208" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Salsa20/8</h4>
<pre><code class="hljs css language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R(a,b) (((a) <span class="hljs-meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">salsa20_word_specification</span><span class="hljs-params">(uint32 out[<span class="hljs-number">16</span>],uint32 in[<span class="hljs-number">16</span>])</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    uint32 x[<span class="hljs-number">16</span>];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">16</span>;++i) x[i] = in[i];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">8</span>;i &gt; <span class="hljs-number">0</span>;i -= <span class="hljs-number">2</span>) {
        x[ <span class="hljs-number">4</span>] ^= R(x[ <span class="hljs-number">0</span>]+x[<span class="hljs-number">12</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">8</span>] ^= R(x[ <span class="hljs-number">4</span>]+x[ <span class="hljs-number">0</span>], <span class="hljs-number">9</span>);
        x[<span class="hljs-number">12</span>] ^= R(x[ <span class="hljs-number">8</span>]+x[ <span class="hljs-number">4</span>],<span class="hljs-number">13</span>); x[ <span class="hljs-number">0</span>] ^= R(x[<span class="hljs-number">12</span>]+x[ <span class="hljs-number">8</span>],<span class="hljs-number">18</span>);
        x[ <span class="hljs-number">9</span>] ^= R(x[ <span class="hljs-number">5</span>]+x[ <span class="hljs-number">1</span>], <span class="hljs-number">7</span>); x[<span class="hljs-number">13</span>] ^= R(x[ <span class="hljs-number">9</span>]+x[ <span class="hljs-number">5</span>], <span class="hljs-number">9</span>);
        x[ <span class="hljs-number">1</span>] ^= R(x[<span class="hljs-number">13</span>]+x[ <span class="hljs-number">9</span>],<span class="hljs-number">13</span>); x[ <span class="hljs-number">5</span>] ^= R(x[ <span class="hljs-number">1</span>]+x[<span class="hljs-number">13</span>],<span class="hljs-number">18</span>);
        x[<span class="hljs-number">14</span>] ^= R(x[<span class="hljs-number">10</span>]+x[ <span class="hljs-number">6</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">2</span>] ^= R(x[<span class="hljs-number">14</span>]+x[<span class="hljs-number">10</span>], <span class="hljs-number">9</span>);
        x[ <span class="hljs-number">6</span>] ^= R(x[ <span class="hljs-number">2</span>]+x[<span class="hljs-number">14</span>],<span class="hljs-number">13</span>); x[<span class="hljs-number">10</span>] ^= R(x[ <span class="hljs-number">6</span>]+x[ <span class="hljs-number">2</span>],<span class="hljs-number">18</span>);
        x[ <span class="hljs-number">3</span>] ^= R(x[<span class="hljs-number">15</span>]+x[<span class="hljs-number">11</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">7</span>] ^= R(x[ <span class="hljs-number">3</span>]+x[<span class="hljs-number">15</span>], <span class="hljs-number">9</span>);
        x[<span class="hljs-number">11</span>] ^= R(x[ <span class="hljs-number">7</span>]+x[ <span class="hljs-number">3</span>],<span class="hljs-number">13</span>); x[<span class="hljs-number">15</span>] ^= R(x[<span class="hljs-number">11</span>]+x[ <span class="hljs-number">7</span>],<span class="hljs-number">18</span>);
        x[ <span class="hljs-number">1</span>] ^= R(x[ <span class="hljs-number">0</span>]+x[ <span class="hljs-number">3</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">2</span>] ^= R(x[ <span class="hljs-number">1</span>]+x[ <span class="hljs-number">0</span>], <span class="hljs-number">9</span>);
        x[ <span class="hljs-number">3</span>] ^= R(x[ <span class="hljs-number">2</span>]+x[ <span class="hljs-number">1</span>],<span class="hljs-number">13</span>); x[ <span class="hljs-number">0</span>] ^= R(x[ <span class="hljs-number">3</span>]+x[ <span class="hljs-number">2</span>],<span class="hljs-number">18</span>);
        x[ <span class="hljs-number">6</span>] ^= R(x[ <span class="hljs-number">5</span>]+x[ <span class="hljs-number">4</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">7</span>] ^= R(x[ <span class="hljs-number">6</span>]+x[ <span class="hljs-number">5</span>], <span class="hljs-number">9</span>);
        x[ <span class="hljs-number">4</span>] ^= R(x[ <span class="hljs-number">7</span>]+x[ <span class="hljs-number">6</span>],<span class="hljs-number">13</span>); x[ <span class="hljs-number">5</span>] ^= R(x[ <span class="hljs-number">4</span>]+x[ <span class="hljs-number">7</span>],<span class="hljs-number">18</span>);
        x[<span class="hljs-number">11</span>] ^= R(x[<span class="hljs-number">10</span>]+x[ <span class="hljs-number">9</span>], <span class="hljs-number">7</span>); x[ <span class="hljs-number">8</span>] ^= R(x[<span class="hljs-number">11</span>]+x[<span class="hljs-number">10</span>], <span class="hljs-number">9</span>);
        x[ <span class="hljs-number">9</span>] ^= R(x[ <span class="hljs-number">8</span>]+x[<span class="hljs-number">11</span>],<span class="hljs-number">13</span>); x[<span class="hljs-number">10</span>] ^= R(x[ <span class="hljs-number">9</span>]+x[ <span class="hljs-number">8</span>],<span class="hljs-number">18</span>);
        x[<span class="hljs-number">12</span>] ^= R(x[<span class="hljs-number">15</span>]+x[<span class="hljs-number">14</span>], <span class="hljs-number">7</span>); x[<span class="hljs-number">13</span>] ^= R(x[<span class="hljs-number">12</span>]+x[<span class="hljs-number">15</span>], <span class="hljs-number">9</span>);
        x[<span class="hljs-number">14</span>] ^= R(x[<span class="hljs-number">13</span>]+x[<span class="hljs-number">12</span>],<span class="hljs-number">13</span>); x[<span class="hljs-number">15</span>] ^= R(x[<span class="hljs-number">14</span>]+x[<span class="hljs-number">13</span>],<span class="hljs-number">18</span>);
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">16</span>;++i) out[i] = x[i] + in[i];
}

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="scryptblockmix"></a><a href="#scryptblockmix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>scryptBlockMix</h4>
<pre><code class="hljs css language-c++"> Parameters:
            r Block size parameter.
   Input:
            B[0] || B[1] || ... || B[2 * r - 1]
                   Input octet string (of size 128 * r octets),
                   treated as 2 * r 64-octet blocks,
                   where each element in B is a 64-octet block.
   Output:
            B'[0] || B'[1] || ... || B'[2 * r - 1]
                   Output octet string.
   Steps:
     1. X = B[2 * r - 1]
     2. for i = 0 to 2 * r - 1 do
          T = X xor B[i]
          X = Salsa (T)
          Y[i] = X
        end for
     3. B' = (Y[0], Y[2], ..., Y[2 * r - 2],
              Y[1], Y[3], ..., Y[2 * r - 1])

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="scryptromix"></a><a href="#scryptromix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>scryptROMix</h4>
<pre><code class="hljs css language-c++"> Input:
            r Block <span class="hljs-built_in">size</span> parameter.
            B Input octet <span class="hljs-built_in">vector</span> of length <span class="hljs-number">128</span> * r octets.
            N CPU/Memory cost parameter, must be larger than <span class="hljs-number">1</span>,
                    a power of <span class="hljs-number">2</span>, <span class="hljs-keyword">and</span> less than <span class="hljs-number">2</span>^(<span class="hljs-number">128</span> * r / <span class="hljs-number">8</span>).
   Output:
            B<span class="hljs-number">'</span> Output octet <span class="hljs-built_in">vector</span> of length <span class="hljs-number">128</span> * r octets.
   Steps:
     <span class="hljs-number">1.</span> X = B
     <span class="hljs-number">2.</span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to N - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
          V[i] = X
          X = scryptBlockMix (X)
        <span class="hljs-built_in">end</span> <span class="hljs-keyword">for</span>
     <span class="hljs-number">3.</span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to N - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
          j = Integerify (X) mod N
                 where Integerify (B[<span class="hljs-number">0</span>] ... B[<span class="hljs-number">2</span> * r - <span class="hljs-number">1</span>]) is defined
                 as the result of interpreting B[<span class="hljs-number">2</span> * r - <span class="hljs-number">1</span>] as a
                 little-endian integer.
          T = X <span class="hljs-keyword">xor</span> V[j]
          X = scryptBlockMix (T)
        <span class="hljs-built_in">end</span> <span class="hljs-keyword">for</span>
     <span class="hljs-number">4.</span> B<span class="hljs-number">'</span> = X

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="scrypt"></a><a href="#scrypt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>scrypt</h4>
<pre><code class="hljs css language-c++">Input:
            P Passphrase, an octet string.
            S Salt, an octet string.
            N CPU/Memory cost parameter, must be larger than 1,
                    a power of 2, and less than 2^(128 * r / 8).
            r Block size parameter.
            p Parallelization parameter, a positive integer
                    less than or equal to ((2^32-1) * hLen) / MFLen
                    where hLen is 32 and MFlen is 128 * r.
            dkLen Intended output length in octets of the derived
                    key; a positive integer less than or equal to
                    (2^32 - 1) * hLen where hLen is 32.
   Output:
            DK Derived key, of length dkLen octets.
   Steps:
    1. Initialize an array B consisting of p blocks of 128 * r octets
       each:
        B[0] || B[1] || ... || B[p - 1] =
          PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r)
    2. for i = 0 to p - 1 do
          B[i] = scryptROMix (r, B[i], N)
        end for
    3. DK = PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 
                                        1, dkLen)
</code></pre>
<p>挖矿算法中，选取的参数为：</p>
<ul>
<li>P：区块头；</li>
<li>S：区块头；</li>
<li>N：固定为1024；</li>
<li>r：固定为1；</li>
<li>p：固定为1；</li>
<li>dkLen：固定为32，即输出长度为32个字节。</li>
</ul>
<p>因此，莱特币的区块头哈希值为 powhash = scrypt(blockheader, blockheader, 1024, 1, 1, 32)。可以参考莱特币获取区块头哈希的Go语言版本实现。</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Copyright (c) 2013-2016 The btcsuite developers</span>
<span class="hljs-comment">// Use of this source code is governed by an ISC</span>
<span class="hljs-comment">// license that can be found in the LICENSE file.</span>

<span class="hljs-keyword">package</span> wire

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bytes"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"time"</span>

    <span class="hljs-string">"golang.org/x/crypto/scrypt"</span>

    <span class="hljs-string">"github.com/ltcsuite/ltcd/chaincfg/chainhash"</span>
)

<span class="hljs-comment">// MaxBlockHeaderPayload is the maximum number of bytes a block header can be.</span>
<span class="hljs-comment">// Version 4 bytes + Timestamp 4 bytes + Bits 4 bytes + Nonce 4 bytes +</span>
<span class="hljs-comment">// PrevBlock and MerkleRoot hashes.</span>
<span class="hljs-keyword">const</span> MaxBlockHeaderPayload = <span class="hljs-number">16</span> + (chainhash.HashSize * <span class="hljs-number">2</span>)

<span class="hljs-comment">// BlockHeader defines information about a block and is used in the bitcoin</span>
<span class="hljs-comment">// block (MsgBlock) and headers (MsgHeaders) messages.</span>
<span class="hljs-keyword">type</span> BlockHeader <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// Version of the block.  This is not the same as the protocol version.</span>
    Version <span class="hljs-keyword">int32</span>

    <span class="hljs-comment">// Hash of the previous block header in the block chain.</span>
    PrevBlock chainhash.Hash

    <span class="hljs-comment">// Merkle tree reference to hash of all transactions for the block.</span>
    MerkleRoot chainhash.Hash

    <span class="hljs-comment">// Time the block was created.  This is, unfortunately, encoded as a</span>
    <span class="hljs-comment">// uint32 on the wire and therefore is limited to 2106.</span>
    Timestamp time.Time

    <span class="hljs-comment">// Difficulty target for the block.</span>
    Bits <span class="hljs-keyword">uint32</span>

    <span class="hljs-comment">// Nonce used to generate the block.</span>
    Nonce <span class="hljs-keyword">uint32</span>
}

<span class="hljs-comment">// blockHeaderLen is a constant that represents the number of bytes for a block</span>
<span class="hljs-comment">// header.</span>
<span class="hljs-keyword">const</span> blockHeaderLen = <span class="hljs-number">80</span>

<span class="hljs-comment">// BlockHash computes the block identifier hash for the given block header.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">BlockHash</span><span class="hljs-params">()</span> <span class="hljs-title">chainhash</span>.<span class="hljs-title">Hash</span></span> {
    <span class="hljs-comment">// Encode the header and double sha256 everything prior to the number of</span>
    <span class="hljs-comment">// transactions.  Ignore the error returns since there is no way the</span>
    <span class="hljs-comment">// encode could fail except being out of memory which would cause a</span>
    <span class="hljs-comment">// run-time panic.</span>
    buf := bytes.NewBuffer(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, MaxBlockHeaderPayload))
    _ = writeBlockHeader(buf, <span class="hljs-number">0</span>, h)

    <span class="hljs-keyword">return</span> chainhash.DoubleHashH(buf.Bytes())
}

<span class="hljs-comment">// PowHash returns the litecoin scrypt hash of this block header. This value is</span>
<span class="hljs-comment">// used to check the PoW on blocks advertised on the network.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">PowHash</span><span class="hljs-params">()</span> <span class="hljs-params">(*chainhash.Hash, error)</span></span> {
    <span class="hljs-keyword">var</span> powHash chainhash.Hash

    buf := bytes.NewBuffer(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, MaxBlockHeaderPayload))
    _ = writeBlockHeader(buf, <span class="hljs-number">0</span>, h)

    scryptHash, err := scrypt.Key(buf.Bytes(), buf.Bytes(), <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    }
    <span class="hljs-built_in">copy</span>(powHash[:], scryptHash)

    <span class="hljs-keyword">return</span> &amp;powHash, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// BtcDecode decodes r using the bitcoin protocol encoding into the receiver.</span>
<span class="hljs-comment">// This is part of the Message interface implementation.</span>
<span class="hljs-comment">// See Deserialize for decoding block headers stored to disk, such as in a</span>
<span class="hljs-comment">// database, as opposed to decoding block headers from the wire.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">BtcDecode</span><span class="hljs-params">(r io.Reader, pver <span class="hljs-keyword">uint32</span>, enc MessageEncoding)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> readBlockHeader(r, pver, h)
}

<span class="hljs-comment">// BtcEncode encodes the receiver to w using the bitcoin protocol encoding.</span>
<span class="hljs-comment">// This is part of the Message interface implementation.</span>
<span class="hljs-comment">// See Serialize for encoding block headers to be stored to disk, such as in a</span>
<span class="hljs-comment">// database, as opposed to encoding block headers for the wire.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">BtcEncode</span><span class="hljs-params">(w io.Writer, pver <span class="hljs-keyword">uint32</span>, enc MessageEncoding)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> writeBlockHeader(w, pver, h)
}

<span class="hljs-comment">// Deserialize decodes a block header from r into the receiver using a format</span>
<span class="hljs-comment">// that is suitable for long-term storage such as a database while respecting</span>
<span class="hljs-comment">// the Version field.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">Deserialize</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-comment">// At the current time, there is no difference between the wire encoding</span>
    <span class="hljs-comment">// at protocol version 0 and the stable long-term storage format.  As</span>
    <span class="hljs-comment">// a result, make use of readBlockHeader.</span>
    <span class="hljs-keyword">return</span> readBlockHeader(r, <span class="hljs-number">0</span>, h)
}

<span class="hljs-comment">// Serialize encodes a block header from r into the receiver using a format</span>
<span class="hljs-comment">// that is suitable for long-term storage such as a database while respecting</span>
<span class="hljs-comment">// the Version field.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BlockHeader)</span> <span class="hljs-title">Serialize</span><span class="hljs-params">(w io.Writer)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-comment">// At the current time, there is no difference between the wire encoding</span>
    <span class="hljs-comment">// at protocol version 0 and the stable long-term storage format.  As</span>
    <span class="hljs-comment">// a result, make use of writeBlockHeader.</span>
    <span class="hljs-keyword">return</span> writeBlockHeader(w, <span class="hljs-number">0</span>, h)
}

<span class="hljs-comment">// NewBlockHeader returns a new BlockHeader using the provided version, previous</span>
<span class="hljs-comment">// block hash, merkle root hash, difficulty bits, and nonce used to generate the</span>
<span class="hljs-comment">// block with defaults for the remaining fields.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBlockHeader</span><span class="hljs-params">(version <span class="hljs-keyword">int32</span>, prevHash, merkleRootHash *chainhash.Hash,
    bits <span class="hljs-keyword">uint32</span>, nonce <span class="hljs-keyword">uint32</span>)</span> *<span class="hljs-title">BlockHeader</span></span> {

    <span class="hljs-comment">// Limit the timestamp to one second precision since the protocol</span>
    <span class="hljs-comment">// doesn't support better.</span>
    <span class="hljs-keyword">return</span> &amp;BlockHeader{
        Version:    version,
        PrevBlock:  *prevHash,
        MerkleRoot: *merkleRootHash,
        Timestamp:  time.Unix(time.Now().Unix(), <span class="hljs-number">0</span>),
        Bits:       bits,
        Nonce:      nonce,
    }
}

<span class="hljs-comment">// readBlockHeader reads a bitcoin block header from r.  See Deserialize for</span>
<span class="hljs-comment">// decoding block headers stored to disk, such as in a database, as opposed to</span>
<span class="hljs-comment">// decoding from the wire.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readBlockHeader</span><span class="hljs-params">(r io.Reader, pver <span class="hljs-keyword">uint32</span>, bh *BlockHeader)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> readElements(r, &amp;bh.Version, &amp;bh.PrevBlock, &amp;bh.MerkleRoot,
        (*uint32Time)(&amp;bh.Timestamp), &amp;bh.Bits, &amp;bh.Nonce)
}

<span class="hljs-comment">// writeBlockHeader writes a bitcoin block header to w.  See Serialize for</span>
<span class="hljs-comment">// encoding block headers to be stored to disk, such as in a database, as</span>
<span class="hljs-comment">// opposed to encoding for the wire.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeBlockHeader</span><span class="hljs-params">(w io.Writer, pver <span class="hljs-keyword">uint32</span>, bh *BlockHeader)</span> <span class="hljs-title">error</span></span> {
    sec := <span class="hljs-keyword">uint32</span>(bh.Timestamp.Unix())
    <span class="hljs-keyword">return</span> writeElements(w, bh.Version, &amp;bh.PrevBlock, &amp;bh.MerkleRoot,
        sec, bh.Bits, bh.Nonce)
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="poa共识算法"></a><a href="#poa共识算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>POA共识算法</h2>
<h3><a class="anchor" aria-hidden="true" id="poa产生的背景"></a><a href="#poa产生的背景" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>POA产生的背景</h3>
<p>如果你想使用Simplechain搭建一个联盟/私有链, 并要求该链交易成本更低甚至没有, 交易延时更低,并发更高, 还拥有完全的控制权(意味着被攻击概率更低). 目前Simplechain采用PoW是不能满足要求的。</p>
<ul>
<li><p>首先, pow存在51%攻击问题, 恶意挖矿者超过全网算力的51%后基本上就能完全控制整个网络. 由于链无法被更改, 已上链的数据也无法更改, 但恶意挖矿者也可以做一些DoS攻击阻止合法交易上链,考虑到具有相同创世块的旷工都能加入你的网络, 潜在的安全隐患会长期存在.</p></li>
<li><p>其次, PoW大量的电力资源消耗也是需要作为后续成本考虑. PoS可以解决部分Pow问题, 比如节约电力,在一定程度上保护了51％的攻击(恶意旷工会被惩罚), 但从控制权和安全考虑还有欠缺, 因为PoS还是允许任何符合条件的旷工加入。</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="poa的特点"></a><a href="#poa的特点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>POA的特点</h3>
<ul>
<li>PoA是依靠预设好的授权节点(signers)，负责产生block.</li>
<li>可以由已授权的signer选举(投票超过50%)加入新的signer。</li>
<li>即使存在恶意signer,他最多只能攻击连续块(数量是 (SIGNER_COUNT / 2) + 1) 中的1个,期间可以由其他signer投票踢出该恶意signer。</li>
<li>可指定产生block的时间。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="poa的工作流程如下"></a><a href="#poa的工作流程如下" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>POA的工作流程如下</h3>
<ol>
<li>在创世块中指定一组初始授权的signers, 所有地址 保存在创世块Extra字段中</li>
<li>启动挖矿后, 该组signers开始对生成的block进行 签名并广播.</li>
<li>签名结果 保存在区块头的Extra字段中</li>
<li>Extra中更新当前高度已授权的 所有signers的地址 ,因为有新加入或踢出的signer</li>
<li>每一高度都有一个signer处于IN-TURN状态, 其他signer处于OUT-OF-TURN状态, IN-TURN的signer签名的block会 立即广播 , OUT-OF-TURN的signer签名的block会 延时 一点随机时间后再广播, 保证IN-TURN的签名block有更高的优先级上链</li>
<li>如果需要加入一个新的signer, signer通过API接口发起一个proposal, 该proposal通过复用区块头 Coinbase(新signer地址)和Nonce(&quot;0xffffffffffffffff&quot;) 字段广播给其他节点. 所有已授权的signers对该新的signer进行&quot;加入&quot;投票, 如果赞成票超过signers总数的50%, 表示同意加入</li>
<li>如果需要踢出一个旧的signer, 所有已授权的signers对该旧的signer进行&quot;踢出&quot;投票, 如果赞成票超过signers总数的50%, 表示同意踢出</li>
</ol>
<h4><a class="anchor" aria-hidden="true" id="simplechain中如何选择poa共识算法"></a><a href="#simplechain中如何选择poa共识算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simplechain中如何选择POA共识算法</h4>
<p>下载生成新的genesis区块文件，<a href="https://github.com/huangxinglong/picture/raw/master/puppeth">下载地址</a></p>
<p>下载完成以后，通过命令执行<code>生成创世区块</code>的文件,在生成创世区块文件的过程中，可以选择自己想要的共识算法。如下图：</p>
<p><img src="https://i.loli.net/2020/05/26/4sPyNkCZMXIbl1L.png" alt="W4f.png"></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/sipc-docs/docs/docs_15"><span class="arrow-prev">← </span><span>P2P网络</span></a><a class="docs-next button" href="/sipc-docs/docs/docs_17"><span>虚拟机</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#pow共识算法">PoW共识算法</a><ul class="toc-headings"><li><a href="#scrypt算法简介">Scrypt算法简介</a></li><li><a href="#scrypt算法过程">Scrypt算法过程</a></li></ul></li><li><a href="#poa共识算法">POA共识算法</a><ul class="toc-headings"><li><a href="#poa产生的背景">POA产生的背景</a></li><li><a href="#poa的特点">POA的特点</a></li><li><a href="#poa的工作流程如下">POA的工作流程如下</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/sipc-docs/" class="nav-home"></a><div><h5>文档</h5><a href="/sipc-docs/docs/en/doc1.html">快速开始</a><a href="/sipc-docs/docs/en/doc2.html">引导</a><a href="/sipc-docs/docs/en/doc3.html">API接口</a></div><div><h5>社区</h5><a href="/sipc-docs/en/https://t.me/SimpleChainOfficial">Telegram</a><a href="https://medium.com/@SimpleChain" target="_blank" rel="noreferrer noopener">Medium</a><a href="https://twitter.com/SimpleChain">Twitter</a><a href="https://www.linkedin.com/company/simplechain-foundation/" target="_blank" rel="noreferrer noopener">Linkedln</a></div><div><h5>更多</h5><a href="https://www.simplechain.com">官网</a><a href="https://github.com/simplechain-org">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2020 SimpleChain Community</section></footer></div></body></html>